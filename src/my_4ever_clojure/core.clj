(ns my-4ever-clojure.core)

(defn nothing-but-true-1
  [smth]
  (= smth true))

(nothing-but-true-1 true)

(defn simple-math
  [x]
  (= (- 10 (* 2 3)) x))

(simple-math 4)

(defn use-java-str
  [x]
  (= x (.toUpperCase "hello world")))

(use-java-str "HELLO WORLD")

(defn def-lists
  [x y z]
  (= (list x y z) '(:a :b :c)))

(def-lists :a :b :c)

(defn conj-on-list-1
  [l]
  (= l (conj '(2 3 4) 1)))

(conj-on-list-1 '(1 2 3 4))

(defn conj-on-list-2
  [l]
  (= l (conj '(3 4) 2 1)))

(conj-on-list-2 '(1 2 3 4))

(defn def-vectors
  [v]
  (= v (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c)))

(def-vectors [:a :b :c])

(defn conj-on-vector-1
  [v]
  (conj v :a :b :c))

(conj-on-vector-1 [:a :b :c])

(defn comprehed-sets
  [coll]
  (set coll))

(comprehed-sets '(1 2 3 4 1 2 3 4))

(defn conj-on-set-1
  [s]
  (conj s :a "name" 22 #{"yy" "xx"}))

(conj-on-set-1 #{:a :b :c})

(hash-map :a 1 :b 2 :c 3)
((hash-map :a 42 :b 2 :c 3) :a)

(conj {:name "John"} [:age 22] [:city "London"] {:sex "Male" :education "University"})

(first '(1 2 3 4 5))
(second '(1 2 3 4 5))
(last '(1 2 3 4 5))
(rest '(1 2 3 4 5))

((defn add-five [x] (+ x 5)) 10)
((fn [y] (+ y 5)) 10)
(#(+ % 40) 2)
((partial + 40) 2)
(conj '(1 2 3) 5)

(defn double-number-15
  [num]
  (* 2 num))

(double-number-15 10)

(defn hello-world-16
  [name]
  (str "Hello, " name))

(hello-world-16 "Jane")

(defn map-17
  [s]
  (map #(+ % 40) s))

(map-17 [1 2 3 4 5 6])

(defn filter-18
  [s]
  (filter #(>= % 10) s))

(filter-18 [1 2 3 11 10 12 4 23 33])

(defn last-element-19
  [s]
  (nth s (- (count s) 1)))

(last-element-19 [1 2 3 4 5])

(defn penultimate-el-20
  [s]
  (first (rest (reverse s))))

(penultimate-el-20 [1 2 3 4 5])

(defn nth-element-21
  [n coll]
  (if (= n 0)
    (first coll)
    (nth-element-21 (- n 1) (rest coll))))

(defn nth-element-21-drop
  [n coll]
  (if (= n 0)
    (first coll)
    (first (drop n coll))))

(nth-element-21 3 [1 2 3 4 5])
(nth-element-21 10 [1 2 3 4 5])
(nth-element-21-drop 4 [1 2 3 4 5])
(nth-element-21-drop 10 [1 2 3 4 5])
(nth-element-21-drop 2 '(1 2 3 4 5))

(defn count-seq-22-map-reduce
  [coll]
  (reduce + (map (constantly 1) coll)))

(count-seq-22-map-reduce [0 11 [1 3] :a 42 5])

(defn count-seq-22-doseq
  [coll]
  (let [count (atom 0)]
    (doseq [x coll]
      (swap! count inc))
    @count))

(count-seq-22-doseq [:a :b :c :d :e :f])

(defn count-seq-22-reduce 
  [coll]
  (reduce (fn [count x] (inc count)) 0 coll))

(count-seq-22-reduce [:a :b :c :d :e :f])

(defn count-seq-22-recur
  [coll]
  (loop [c coll
        counter 0]
    (if (empty? c)
      counter
      (recur (rest c) (inc counter)))))

(count-seq-22-recur [:a :b :c :d :e :f])

; for  is used for list comprehension,
; which is a concise way to create a list (or sequence)
; based on existing lists (or sequences).
(for [x [1 2 3 4 5 6 7 8 9 10] :let [y 0]] (+ y 1))
(for [x [1 2 22] y [3 4 11 33]] [x y])
; for macro allows add condition for filtering with :when 
(for [x (range -2 22) :when (even? x)] (* 10 x))
(map #(set (vector 1% 2% %3)) [1 2 3] ["a" :b :c] ["a" "c" "i" "d"])
(map vector [1 2 3] ["a" :b :c] ["a" "c" "i" "d"])
; for marco allows iterate over multiple collections in parallel
(for [[x y] (map vector [11 22 33] [100 200 300])] (+ x y))
(for [[x y] '([1 2] [10 20])] (+ x y))
; we can make local bindings with :let
(for [x [1 2 3] :let [y (* x 10)]] [x y])
;The sequence generated by for is lazy,
;which means it computes its elements as they are needed.


